name: Build lib check flow


env:
  ORIGIN_REPO_PATH: mmikeww/AHK-v2-script-converter
  AUTOMATIC_MONITOR: true
  FILES: "." # seperate multiple entries with ,
  FILES_MATCHING_FILTER_ARRAY: ''  # "*.ahk" # seperate multiple entries with ,
  EXTRA: mv *.ahk lib # do an extra command like renaming
  USERNAME: ${{ github.actor }} 
  ADDRESS_SUFFIX: users.noreply.github.com
  TOKEN_NAME: ACCESS_TOKEN # name of token defined in the target repo's settings, needed for private repos
  # ORIGIN_BRANCH: source_alternate_branch # uncomment to takes files from a non default source branch
  # TARGET_BRANCH: target_alternate_branch # uncomment to monitor a non default target branch
  # TARGET_PATH: target_alternate_path # uncomment to monitor a non default target branch
  THE_SERVER: ${{ github.server_url }}
  ORIGIN_CHECKOUT_TEMP_PATH: remote_repo_clone
  THE_SECRET: ${{ secrets.TOKEN_NAME || 'default_value' }}


on: # Remove # below for non default branches
  workflow_dispatch:
  push:
#    branches:
#      - ${{ env.TARGET_BRANCH }}
#    paths:
#      - ${{ env.TARGET_PATH }}

  
jobs:
  pull-file:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: /home/runner/work/AutoHotkey
    permissions:
      contents: write
    steps:
    
      - name: Check whether to automatically monitor
        if: ${{ github.event_name != 'workflow_dispatch' && env.AUTOMATIC_MONITOR == false }}
        run: |
          echo "Set not to run automatically. Exiting."
          echo "Updating $GITHUB_ENV with exiting1=true" 
          echo "exiting1=true" >> $GITHUB_ENV


      - name: try to climb               # move one level up
        run: |
          echo "Starting dir: " $PWD
# cd only works for one run, resets afterwards â†’ 
    
      - name: Clean Workspace Folder
        run: |
         echo "Cleaning up " $PWD 
         
         rm -rf ./* || true
         rm -rf ./.??* || true
         echo "Done."


      - name: try to create folder
        run: |
          mkdir -v -p AutoHotkey/AutoHotkey
          echo "Created new folder in " $PWD
          ls

      - name: test location
        run: |
          echo "location: " $PWD


      - name: Checkout
        if: env.exiting1 != 'true'
        uses: actions/checkout@v4
        with: 
          sparse-checkout: |
            lib
            inc
          sparse-checkout-cone-mode: false


      - name: Report after first checkout
        run: |
         echo "Contents of " $PWD ": "
         find $PWD -type f -path '*.*' -ls

      - name: Checkout source with token and branch
        if: env.exiting1 != 'true' && env.THE_SECRET != 'default_value' && env.ORIGIN_BRANCH
        uses: actions/checkout@v4
        with:
          repository: ${{ env.ORIGIN_REPO_PATH }}
          ref: ${{ env.ORIGIN_BRANCH }}
          token: ${{ secrets[env.TOKEN_NAME] }}
          path: ${{ env.ORIGIN_CHECKOUT_TEMP_PATH }}
          fetch-depth: 0
          sparse-checkout: |
            lib
            inc
          sparse-checkout-cone-mode: false



      - name: Checkout source with token but without branch
        if: env.exiting1 != 'true' && env.THE_SECRET != 'default_value' && !env.ORIGIN_BRANCH
        uses: actions/checkout@v4
        with:
          repository: ${{ env.ORIGIN_REPO_PATH }}
          token: ${{ secrets[env.TOKEN_NAME] }}
          path: ${{ env.ORIGIN_CHECKOUT_TEMP_PATH }}
          fetch-depth: 0
          sparse-checkout: |
            lib
            inc
          sparse-checkout-cone-mode: false
          
      - name: Checkout source without token but with branch
        if: env.exiting1 != 'true' && env.THE_SECRET == 'default_value' && env.ORIGIN_BRANCH
        uses: actions/checkout@v4
        with:
          repository: ${{ env.ORIGIN_REPO_PATH }}
          ref: ${{ env.ORIGIN_BRANCH }}
          path: ${{ env.ORIGIN_CHECKOUT_TEMP_PATH }}
          fetch-depth: 0
          sparse-checkout: |
            lib
            inc
          sparse-checkout-cone-mode: false

      - name: Checkout source without token and without branch
        if: env.exiting1 != 'true' && env.THE_SECRET == 'default_value' && !env.ORIGIN_BRANCH
        uses: actions/checkout@v4
        with:
          repository: ${{ env.ORIGIN_REPO_PATH }}
          path: ${{ env.ORIGIN_CHECKOUT_TEMP_PATH }}
          fetch-depth: 0
          sparse-checkout: |
            lib
            inc
          sparse-checkout-cone-mode: false

      - name: List files in temp dir
        run: |
         echo "Origin repo cloned to " $ORIGIN_CHECKOUT_TEMP_PATH ": "
         find . -type f -path '*.*' -ls

          
      #           $EXTRA
      # cp -u $FILES_MATCHING_FILTER_ARRAY ../


      # find . -type f -path '*lib*/*.*' -ls

      - name: Update
        if: env.exiting1 != 'true'
        run: |
          cd AutoHotkey\remote_repo_clone
          echo "    files in " $PWD " matching search action: "
          find . -type f -path '*/lib*/*.*'  -ls

          fi


          echo "    copying files..."
          find . -type f -path '*/lib*/*.*'  -exec cp {} . \;
        

          # cp -u -R "*/lib/*" ../
          cd ..
          echo "    files after copying: " $PWD
          find . -type f -path '*/lib*/*.*'  -ls


## execute `process` once for each file
#find . -name \*.txt -exec process {} \;

# execute `process` once with all the files as arguments*:
#find . -name \*.txt -exec process {} +

#find can also cd into each file's directory before running a command by using -execdir instead of -exec, 
# and can be made interactive (prompt before running the command for each file) using -ok instead of -exec (or -okdir instead of -execdir)




          
          
  #    - name: Check for changes
  #      if: env.exiting1 != 'true'
  #      run: |
  #        if git diff --quiet; then
  #          echo "No changes detected. Exiting."
  #          echo "exiting2=true" >> $GITHUB_ENV
  #        fi
          
      - name: Commit
        if: env.exiting1 != 'true' && env.exiting2 != 'true'
        run: |
          git config user.name "$USERNAME"
          git config user.email "$USERNAME@$ADDRESS_SUFFIX"
          git add $FILES_MATCHING_FILTER_ARRAY
          git commit -m "Pulled files from $THE_SERVER/$ORIGIN_REPO_PATH."
      - name: Push
        if: env.exiting1 != 'true' && env.exiting2 != 'true'
        run: |
          if [ -n "$TARGET_BRANCH" ]; then
            git push origin $TARGET_BRANCH
          else
            git push
          fi

